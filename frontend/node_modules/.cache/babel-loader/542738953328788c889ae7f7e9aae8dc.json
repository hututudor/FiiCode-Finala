{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _queryString = require('query-string');\n\nvar _MatchProvider = require('./MatchProvider');\n\nvar _MatchProvider2 = _interopRequireDefault(_MatchProvider);\n\nvar _Broadcasts = require('./Broadcasts');\n\nvar _LocationUtils = require('./LocationUtils');\n\nvar _PropTypes = require('./PropTypes');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar stringifyQuery = function stringifyQuery(query) {\n  return (0, _queryString.stringify)(query).replace(/%20/g, '+');\n};\n\nvar StaticRouter = function (_React$Component) {\n  _inherits(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, StaticRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.transitionTo = function (location) {\n      _this.props.onPush(_this.createLocation(location));\n    }, _this.replaceWith = function (location) {\n      _this.props.onReplace(_this.createLocation(location));\n    }, _this.blockTransitions = function (prompt) {\n      return _this.props.blockTransitions(prompt);\n    }, _this.createHref = function (to) {\n      var path = (0, _LocationUtils.createRouterPath)(to, _this.props.stringifyQuery);\n      if (_this.props.basename) if (path === '/') path = _this.props.basename;else if (path.length >= 2 && path.charAt(0) === '/' && path.charAt(1) === '?') path = _this.props.basename + path.substring(1);else path = _this.props.basename + path;\n      return _this.props.createHref(path);\n    }, _this.state = {\n      location: null\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  StaticRouter.prototype.createLocation = function createLocation(location) {\n    var _props = this.props,\n        parseQueryString = _props.parseQueryString,\n        stringifyQuery = _props.stringifyQuery;\n    return (0, _LocationUtils.createRouterLocation)(location, parseQueryString, stringifyQuery);\n  };\n\n  StaticRouter.prototype.getRouterContext = function getRouterContext() {\n    return {\n      transitionTo: this.transitionTo,\n      replaceWith: this.replaceWith,\n      blockTransitions: this.blockTransitions,\n      createHref: this.createHref\n    };\n  };\n\n  StaticRouter.prototype.getChildContext = function getChildContext() {\n    return {\n      router: this.getRouterContext()\n    };\n  };\n\n  StaticRouter.prototype.componentWillMount = function componentWillMount() {\n    this.setState({\n      location: this.createLocation(this.props.location)\n    });\n  };\n\n  StaticRouter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var nextLocation = this.createLocation(nextProps.location);\n    if (!(0, _LocationUtils.locationsAreEqual)(this.state.location, nextLocation)) this.setState({\n      location: nextLocation\n    });\n  };\n\n  StaticRouter.prototype.render = function render() {\n    var location = this.state.location;\n    var _props2 = this.props,\n        action = _props2.action,\n        children = _props2.children;\n    return _react2.default.createElement(_Broadcasts.LocationBroadcast, {\n      value: location\n    }, _react2.default.createElement(_MatchProvider2.default, null, typeof children === 'function' ? children({\n      action: action,\n      location: location,\n      router: this.getRouterContext()\n    }) : _react2.default.Children.only(children)));\n  };\n\n  return StaticRouter;\n}(_react2.default.Component);\n\nStaticRouter.defaultProps = {\n  stringifyQuery: stringifyQuery,\n  parseQueryString: _queryString.parse,\n  createHref: function createHref(path) {\n    return path;\n  }\n};\nStaticRouter.childContextTypes = {\n  router: _PropTypes.routerContext.isRequired\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  StaticRouter.propTypes = {\n    children: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]),\n    action: _PropTypes.action.isRequired,\n    location: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.string]).isRequired,\n    onPush: _react.PropTypes.func.isRequired,\n    onReplace: _react.PropTypes.func.isRequired,\n    blockTransitions: _react.PropTypes.func,\n    stringifyQuery: _react.PropTypes.func.isRequired,\n    parseQueryString: _react.PropTypes.func.isRequired,\n    createHref: _react.PropTypes.func.isRequired,\n    // TODO: Clarify why this is useful\n    basename: _react.PropTypes.string // TODO: Feels like we should be able to remove this\n\n  };\n}\n\nexports.default = StaticRouter;","map":null,"metadata":{},"sourceType":"script"}